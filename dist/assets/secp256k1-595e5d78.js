import{c$ as Be,d0 as xe,d1 as Se,d2 as Yt,d3 as Ae,d4 as ne,d5 as re,d6 as ft,d7 as oe,d8 as X,d9 as bt,da as Ie,db as wt,dc as Bt,dd as D,de as U,df as ot,dg as Dt,dh as qe,di as Zt,dj as pt,dk as dt,dl as Ct,dm as Oe,dn as Gt,dp as _e,dq as se,dr as Pt,cm as xt}from"./index-a005ad49.js";class ie extends Be{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,xe(n);const r=Se(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(n){return Yt(this),this.iHash.update(n),this}digestInto(n){Yt(this),Ae(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:i,blockLen:c,outputLen:f}=this;return n=n,n.finished=s,n.destroyed=i,n.blockLen=c,n.outputLen=f,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ce=(e,n,t)=>new ie(e,n).update(t).digest();ce.create=(e,n)=>new ie(e,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),H=BigInt(1),rt=BigInt(2),Ne=BigInt(3),zt=BigInt(4),$t=BigInt(5),Wt=BigInt(8);function Z(e,n){const t=e%n;return t>=C?t:n+t}function Le(e,n,t){if(n<C)throw new Error("invalid exponent, negatives unsupported");if(t<=C)throw new Error("invalid modulus");if(t===H)return C;let r=H;for(;n>C;)n&H&&(r=r*e%t),e=e*e%t,n>>=H;return r}function K(e,n,t){let r=e;for(;n-- >C;)r*=r,r%=t;return r}function Vt(e,n){if(e===C)throw new Error("invert: expected non-zero number");if(n<=C)throw new Error("invert: expected positive modulus, got "+n);let t=Z(e,n),r=n,s=C,i=H;for(;t!==C;){const f=r/t,o=r%t,d=s-i*f;r=t,t=o,s=i,i=d}if(r!==H)throw new Error("invert: does not exist");return Z(s,n)}function Re(e){const n=(e-H)/rt;let t,r,s;for(t=e-H,r=0;t%rt===C;t/=rt,r++);for(s=rt;s<e&&Le(s,n,e)!==e-H;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const c=(e+H)/zt;return function(o,d){const w=o.pow(d,c);if(!o.eql(o.sqr(w),d))throw new Error("Cannot find square root");return w}}const i=(t+H)/rt;return function(f,o){if(f.pow(o,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let d=r,w=f.pow(f.mul(f.ONE,s),t),x=f.pow(o,i),u=f.pow(o,t);for(;!f.eql(u,f.ONE);){if(f.eql(u,f.ZERO))return f.ZERO;let b=1;for(let m=f.sqr(u);b<d&&!f.eql(m,f.ONE);b++)m=f.sqr(m);const S=f.pow(w,H<<BigInt(d-b-1));w=f.sqr(S),x=f.mul(x,S),u=f.mul(u,w),d=b}return x}}function Te(e){if(e%zt===Ne){const n=(e+H)/zt;return function(r,s){const i=r.pow(s,n);if(!r.eql(r.sqr(i),s))throw new Error("Cannot find square root");return i}}if(e%Wt===$t){const n=(e-$t)/Wt;return function(r,s){const i=r.mul(s,rt),c=r.pow(i,n),f=r.mul(s,c),o=r.mul(r.mul(f,rt),c),d=r.mul(f,r.sub(o,r.ONE));if(!r.eql(r.sqr(d),s))throw new Error("Cannot find square root");return d}}return Re(e)}const He=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ae(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=He.reduce((r,s)=>(r[s]="function",r),n);return bt(e,t)}function ke(e,n,t){if(t<C)throw new Error("invalid exponent, negatives unsupported");if(t===C)return e.ONE;if(t===H)return n;let r=e.ONE,s=n;for(;t>C;)t&H&&(r=e.mul(r,s)),s=e.sqr(s),t>>=H;return r}function Ze(e,n){const t=new Array(n.length),r=n.reduce((i,c,f)=>e.is0(c)?i:(t[f]=i,e.mul(i,c)),e.ONE),s=e.inv(r);return n.reduceRight((i,c,f)=>e.is0(c)?i:(t[f]=e.mul(i,t[f]),e.mul(i,c)),s),t}function fe(e,n){const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function de(e,n,t=!1,r={}){if(e<=C)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:s,nByteLength:i}=fe(e,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:e,isLE:t,BITS:s,BYTES:i,MASK:ne(s),ZERO:C,ONE:H,create:o=>Z(o,e),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return C<=o&&o<e},is0:o=>o===C,isOdd:o=>(o&H)===H,neg:o=>Z(-o,e),eql:(o,d)=>o===d,sqr:o=>Z(o*o,e),add:(o,d)=>Z(o+d,e),sub:(o,d)=>Z(o-d,e),mul:(o,d)=>Z(o*d,e),pow:(o,d)=>ke(f,o,d),div:(o,d)=>Z(o*Vt(d,e),e),sqrN:o=>o*o,addN:(o,d)=>o+d,subN:(o,d)=>o-d,mulN:(o,d)=>o*d,inv:o=>Vt(o,e),sqrt:r.sqrt||(o=>(c||(c=Te(e)),c(f,o))),invertBatch:o=>Ze(f,o),cmov:(o,d,w)=>w?d:o,toBytes:o=>t?re(o,i):ft(o,i),fromBytes:o=>{if(o.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+o.length);return t?oe(o):X(o)}});return Object.freeze(f)}function le(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function ue(e){const n=le(e);return n+Math.ceil(n/2)}function Ce(e,n,t=!1){const r=e.length,s=le(n),i=ue(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const c=t?oe(e):X(e),f=Z(c,n-H)+H;return t?re(f,s):ft(f,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xt=BigInt(0),vt=BigInt(1);function Lt(e,n){const t=n.negate();return e?t:n}function he(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Rt(e,n){he(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1);return{windows:t,windowSize:r}}function ze(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function Ve(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const Tt=new WeakMap,we=new WeakMap;function Ht(e){return we.get(e)||1}function Ue(e,n){return{constTimeNegate:Lt,hasPrecomputes(t){return Ht(t)!==1},unsafeLadder(t,r,s=e.ZERO){let i=t;for(;r>Xt;)r&vt&&(s=s.add(i)),i=i.double(),r>>=vt;return s},precomputeWindow(t,r){const{windows:s,windowSize:i}=Rt(r,n),c=[];let f=t,o=f;for(let d=0;d<s;d++){o=f,c.push(o);for(let w=1;w<i;w++)o=o.add(f),c.push(o);f=o.double()}return c},wNAF(t,r,s){const{windows:i,windowSize:c}=Rt(t,n);let f=e.ZERO,o=e.BASE;const d=BigInt(2**t-1),w=2**t,x=BigInt(t);for(let u=0;u<i;u++){const b=u*c;let S=Number(s&d);s>>=x,S>c&&(S-=w,s+=vt);const m=b,a=b+Math.abs(S)-1,l=u%2!==0,h=S<0;S===0?o=o.add(Lt(l,r[m])):f=f.add(Lt(h,r[a]))}return{p:f,f:o}},wNAFUnsafe(t,r,s,i=e.ZERO){const{windows:c,windowSize:f}=Rt(t,n),o=BigInt(2**t-1),d=2**t,w=BigInt(t);for(let x=0;x<c;x++){const u=x*f;if(s===Xt)break;let b=Number(s&o);if(s>>=w,b>f&&(b-=d,s+=vt),b===0)continue;let S=r[u+Math.abs(b)-1];b<0&&(S=S.negate()),i=i.add(S)}return i},getPrecomputes(t,r,s){let i=Tt.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&Tt.set(r,s(i))),i},wNAFCached(t,r,s){const i=Ht(t);return this.wNAF(i,this.getPrecomputes(i,t,s),r)},wNAFCachedUnsafe(t,r,s,i){const c=Ht(t);return c===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,t,s),r,i)},setWindowSize(t,r){he(r,n),we.set(t,r),Tt.delete(t)}}}function Me(e,n,t,r){if(ze(t,e),Ve(r,n),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=e.ZERO,i=Ie(BigInt(t.length)),c=i>12?i-3:i>4?i-2:i?2:1,f=(1<<c)-1,o=new Array(f+1).fill(s),d=Math.floor((n.BITS-1)/c)*c;let w=s;for(let x=d;x>=0;x-=c){o.fill(s);for(let b=0;b<r.length;b++){const S=r[b],m=Number(S>>BigInt(x)&BigInt(f));o[m]=o[m].add(t[b])}let u=s;for(let b=o.length-1,S=s;b>0;b--)S=S.add(o[b]),u=u.add(S);if(w=w.add(u),x!==0)for(let b=0;b<c;b++)w=w.double()}return w}function ge(e){return ae(e.Fp),bt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...fe(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Qt(e){e.lowS!==void 0&&wt("lowS",e.lowS),e.prehash!==void 0&&wt("prehash",e.prehash)}function Pe(e){const n=ge(e);bt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=n;if(t){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:je,hexToBytes:Ke}=Oe;class Ye extends Error{constructor(n=""){super(n)}}const W={Err:Ye,_tlv:{encode:(e,n)=>{const{Err:t}=W;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,s=pt(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?pt(s.length/2|128):"";return pt(e)+i+s+n},decode(e,n){const{Err:t}=W;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const s=n[r++],i=!!(s&128);let c=0;if(!i)c=s;else{const o=s&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");const d=n.subarray(r,r+o);if(d.length!==o)throw new t("tlv.decode: length bytes not complete");if(d[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const w of d)c=c<<8|w;if(r+=o,c<128)throw new t("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new t("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(e){const{Err:n}=W;if(e<G)throw new n("integer: negative integers are not allowed");let t=pt(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=W;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return je(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=W,s=typeof e=="string"?Ke(e):e;dt(s);const{v:i,l:c}=r.decode(48,s);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:o}=r.decode(2,i),{v:d,l:w}=r.decode(2,o);if(w.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(f),s:t.decode(d)}},hexFromSig(e){const{_tlv:n,_int:t}=W,r=n.encode(2,t.encode(e.r)),s=n.encode(2,t.encode(e.s)),i=r+s;return n.encode(48,i)}},G=BigInt(0),R=BigInt(1),J=BigInt(2),St=BigInt(3),Jt=BigInt(4);function De(e){const n=Pe(e),{Fp:t}=n,r=de(n.n,n.nBitLength),s=n.toBytes||((m,a,l)=>{const h=a.toAffine();return D(Uint8Array.from([4]),t.toBytes(h.x),t.toBytes(h.y))}),i=n.fromBytes||(m=>{const a=m.subarray(1),l=t.fromBytes(a.subarray(0,t.BYTES)),h=t.fromBytes(a.subarray(t.BYTES,2*t.BYTES));return{x:l,y:h}});function c(m){const{a,b:l}=n,h=t.sqr(m),y=t.mul(h,m);return t.add(t.add(y,t.mul(m,a)),l)}if(!t.eql(t.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(m){return Bt(m,R,n.n)}function o(m){const{allowedPrivateKeyLengths:a,nByteLength:l,wrapPrivateKey:h,n:y}=n;if(a&&typeof m!="bigint"){if(Zt(m)&&(m=Ct(m)),typeof m!="string"||!a.includes(m.length))throw new Error("invalid private key");m=m.padStart(l*2,"0")}let v;try{v=typeof m=="bigint"?m:X(U("private key",m,l))}catch{throw new Error("invalid private key, expected hex or "+l+" bytes, got "+typeof m)}return h&&(v=Z(v,y)),ot("private key",v,R,y),v}function d(m){if(!(m instanceof u))throw new Error("ProjectivePoint expected")}const w=Gt((m,a)=>{const{px:l,py:h,pz:y}=m;if(t.eql(y,t.ONE))return{x:l,y:h};const v=m.is0();a==null&&(a=v?t.ONE:t.inv(y));const _=t.mul(l,a),q=t.mul(h,a),B=t.mul(y,a);if(v)return{x:t.ZERO,y:t.ZERO};if(!t.eql(B,t.ONE))throw new Error("invZ was invalid");return{x:_,y:q}}),x=Gt(m=>{if(m.is0()){if(n.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}const{x:a,y:l}=m.toAffine();if(!t.isValid(a)||!t.isValid(l))throw new Error("bad point: x or y not FE");const h=t.sqr(l),y=c(a);if(!t.eql(h,y))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class u{constructor(a,l,h){if(this.px=a,this.py=l,this.pz=h,a==null||!t.isValid(a))throw new Error("x required");if(l==null||!t.isValid(l))throw new Error("y required");if(h==null||!t.isValid(h))throw new Error("z required");Object.freeze(this)}static fromAffine(a){const{x:l,y:h}=a||{};if(!a||!t.isValid(l)||!t.isValid(h))throw new Error("invalid affine point");if(a instanceof u)throw new Error("projective point not allowed");const y=v=>t.eql(v,t.ZERO);return y(l)&&y(h)?u.ZERO:new u(l,h,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const l=t.invertBatch(a.map(h=>h.pz));return a.map((h,y)=>h.toAffine(l[y])).map(u.fromAffine)}static fromHex(a){const l=u.fromAffine(i(U("pointHex",a)));return l.assertValidity(),l}static fromPrivateKey(a){return u.BASE.multiply(o(a))}static msm(a,l){return Me(u,r,a,l)}_setWindowSize(a){S.setWindowSize(this,a)}assertValidity(){x(this)}hasEvenY(){const{y:a}=this.toAffine();if(t.isOdd)return!t.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){d(a);const{px:l,py:h,pz:y}=this,{px:v,py:_,pz:q}=a,B=t.eql(t.mul(l,q),t.mul(v,y)),I=t.eql(t.mul(h,q),t.mul(_,y));return B&&I}negate(){return new u(this.px,t.neg(this.py),this.pz)}double(){const{a,b:l}=n,h=t.mul(l,St),{px:y,py:v,pz:_}=this;let q=t.ZERO,B=t.ZERO,I=t.ZERO,A=t.mul(y,y),z=t.mul(v,v),T=t.mul(_,_),L=t.mul(y,v);return L=t.add(L,L),I=t.mul(y,_),I=t.add(I,I),q=t.mul(a,I),B=t.mul(h,T),B=t.add(q,B),q=t.sub(z,B),B=t.add(z,B),B=t.mul(q,B),q=t.mul(L,q),I=t.mul(h,I),T=t.mul(a,T),L=t.sub(A,T),L=t.mul(a,L),L=t.add(L,I),I=t.add(A,A),A=t.add(I,A),A=t.add(A,T),A=t.mul(A,L),B=t.add(B,A),T=t.mul(v,_),T=t.add(T,T),A=t.mul(T,L),q=t.sub(q,A),I=t.mul(T,z),I=t.add(I,I),I=t.add(I,I),new u(q,B,I)}add(a){d(a);const{px:l,py:h,pz:y}=this,{px:v,py:_,pz:q}=a;let B=t.ZERO,I=t.ZERO,A=t.ZERO;const z=n.a,T=t.mul(n.b,St);let L=t.mul(l,v),j=t.mul(h,_),g=t.mul(y,q),E=t.add(l,h),p=t.add(v,_);E=t.mul(E,p),p=t.add(L,j),E=t.sub(E,p),p=t.add(l,y);let O=t.add(v,q);return p=t.mul(p,O),O=t.add(L,g),p=t.sub(p,O),O=t.add(h,y),B=t.add(_,q),O=t.mul(O,B),B=t.add(j,g),O=t.sub(O,B),A=t.mul(z,p),B=t.mul(T,g),A=t.add(B,A),B=t.sub(j,A),A=t.add(j,A),I=t.mul(B,A),j=t.add(L,L),j=t.add(j,L),g=t.mul(z,g),p=t.mul(T,p),j=t.add(j,g),g=t.sub(L,g),g=t.mul(z,g),p=t.add(p,g),L=t.mul(j,p),I=t.add(I,L),L=t.mul(O,p),B=t.mul(E,B),B=t.sub(B,L),L=t.mul(E,j),A=t.mul(O,A),A=t.add(A,L),new u(B,I,A)}subtract(a){return this.add(a.negate())}is0(){return this.equals(u.ZERO)}wNAF(a){return S.wNAFCached(this,a,u.normalizeZ)}multiplyUnsafe(a){const{endo:l,n:h}=n;ot("scalar",a,G,h);const y=u.ZERO;if(a===G)return y;if(this.is0()||a===R)return this;if(!l||S.hasPrecomputes(this))return S.wNAFCachedUnsafe(this,a,u.normalizeZ);let{k1neg:v,k1:_,k2neg:q,k2:B}=l.splitScalar(a),I=y,A=y,z=this;for(;_>G||B>G;)_&R&&(I=I.add(z)),B&R&&(A=A.add(z)),z=z.double(),_>>=R,B>>=R;return v&&(I=I.negate()),q&&(A=A.negate()),A=new u(t.mul(A.px,l.beta),A.py,A.pz),I.add(A)}multiply(a){const{endo:l,n:h}=n;ot("scalar",a,R,h);let y,v;if(l){const{k1neg:_,k1:q,k2neg:B,k2:I}=l.splitScalar(a);let{p:A,f:z}=this.wNAF(q),{p:T,f:L}=this.wNAF(I);A=S.constTimeNegate(_,A),T=S.constTimeNegate(B,T),T=new u(t.mul(T.px,l.beta),T.py,T.pz),y=A.add(T),v=z.add(L)}else{const{p:_,f:q}=this.wNAF(a);y=_,v=q}return u.normalizeZ([y,v])[0]}multiplyAndAddUnsafe(a,l,h){const y=u.BASE,v=(q,B)=>B===G||B===R||!q.equals(y)?q.multiplyUnsafe(B):q.multiply(B),_=v(this,l).add(v(a,h));return _.is0()?void 0:_}toAffine(a){return w(this,a)}isTorsionFree(){const{h:a,isTorsionFree:l}=n;if(a===R)return!0;if(l)return l(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:l}=n;return a===R?this:l?l(u,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return wt("isCompressed",a),this.assertValidity(),s(u,this,a)}toHex(a=!0){return wt("isCompressed",a),Ct(this.toRawBytes(a))}}u.BASE=new u(n.Gx,n.Gy,t.ONE),u.ZERO=new u(t.ZERO,t.ONE,t.ZERO);const b=n.nBitLength,S=Ue(u,n.endo?Math.ceil(b/2):b);return{CURVE:n,ProjectivePoint:u,normPrivateKeyToScalar:o,weierstrassEquation:c,isWithinCurveOrder:f}}function Ge(e){const n=ge(e);return bt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function $e(e){const n=Ge(e),{Fp:t,n:r}=n,s=t.BYTES+1,i=2*t.BYTES+1;function c(g){return Z(g,r)}function f(g){return Vt(g,r)}const{ProjectivePoint:o,normPrivateKeyToScalar:d,weierstrassEquation:w,isWithinCurveOrder:x}=De({...n,toBytes(g,E,p){const O=E.toAffine(),N=t.toBytes(O.x),k=D;return wt("isCompressed",p),p?k(Uint8Array.from([E.hasEvenY()?2:3]),N):k(Uint8Array.from([4]),N,t.toBytes(O.y))},fromBytes(g){const E=g.length,p=g[0],O=g.subarray(1);if(E===s&&(p===2||p===3)){const N=X(O);if(!Bt(N,R,t.ORDER))throw new Error("Point is not on curve");const k=w(N);let M;try{M=t.sqrt(k)}catch(Y){const P=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+P)}const V=(M&R)===R;return(p&1)===1!==V&&(M=t.neg(M)),{x:N,y:M}}else if(E===i&&p===4){const N=t.fromBytes(O.subarray(0,t.BYTES)),k=t.fromBytes(O.subarray(t.BYTES,2*t.BYTES));return{x:N,y:k}}else{const N=s,k=i;throw new Error("invalid Point, expected length of "+N+", or uncompressed "+k+", got "+E)}}}),u=g=>Ct(ft(g,n.nByteLength));function b(g){const E=r>>R;return g>E}function S(g){return b(g)?c(-g):g}const m=(g,E,p)=>X(g.slice(E,p));class a{constructor(E,p,O){this.r=E,this.s=p,this.recovery=O,this.assertValidity()}static fromCompact(E){const p=n.nByteLength;return E=U("compactSignature",E,p*2),new a(m(E,0,p),m(E,p,2*p))}static fromDER(E){const{r:p,s:O}=W.toSig(U("DER",E));return new a(p,O)}assertValidity(){ot("r",this.r,R,r),ot("s",this.s,R,r)}addRecoveryBit(E){return new a(this.r,this.s,E)}recoverPublicKey(E){const{r:p,s:O,recovery:N}=this,k=q(U("msgHash",E));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const M=N===2||N===3?p+n.n:p;if(M>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=N&1?"03":"02",$=o.fromHex(V+u(M)),Y=f(M),P=c(-k*Y),st=c(O*Y),Q=o.BASE.multiplyAndAddUnsafe($,P,st);if(!Q)throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Dt(this.toDERHex())}toDERHex(){return W.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Dt(this.toCompactHex())}toCompactHex(){return u(this.r)+u(this.s)}}const l={isValidPrivateKey(g){try{return d(g),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const g=ue(n.n);return Ce(n.randomBytes(g),n.n)},precompute(g=8,E=o.BASE){return E._setWindowSize(g),E.multiply(BigInt(3)),E}};function h(g,E=!0){return o.fromPrivateKey(g).toRawBytes(E)}function y(g){const E=Zt(g),p=typeof g=="string",O=(E||p)&&g.length;return E?O===s||O===i:p?O===2*s||O===2*i:g instanceof o}function v(g,E,p=!0){if(y(g))throw new Error("first arg must be private key");if(!y(E))throw new Error("second arg must be public key");return o.fromHex(E).multiply(d(g)).toRawBytes(p)}const _=n.bits2int||function(g){if(g.length>8192)throw new Error("input is too large");const E=X(g),p=g.length*8-n.nBitLength;return p>0?E>>BigInt(p):E},q=n.bits2int_modN||function(g){return c(_(g))},B=ne(n.nBitLength);function I(g){return ot("num < 2^"+n.nBitLength,g,G,B),ft(g,n.nByteLength)}function A(g,E,p=z){if(["recovered","canonical"].some(et=>et in p))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:N}=n;let{lowS:k,prehash:M,extraEntropy:V}=p;k==null&&(k=!0),g=U("msgHash",g),Qt(p),M&&(g=U("prehashed msgHash",O(g)));const $=q(g),Y=d(E),P=[I(Y),I($)];if(V!=null&&V!==!1){const et=V===!0?N(t.BYTES):V;P.push(U("extraEntropy",et))}const st=D(...P),Q=$;function _t(et){const it=_(et);if(!x(it))return;const Nt=f(it),lt=o.BASE.multiply(it).toAffine(),nt=c(lt.x);if(nt===G)return;const ut=c(Nt*c(Q+nt*Y));if(ut===G)return;let ht=(lt.x===nt?0:2)|Number(lt.y&R),ct=ut;return k&&b(ut)&&(ct=S(ut),ht^=1),new a(nt,ct,ht)}return{seed:st,k2sig:_t}}const z={lowS:n.lowS,prehash:!1},T={lowS:n.lowS,prehash:!1};function L(g,E,p=z){const{seed:O,k2sig:N}=A(g,E,p),k=n;return qe(k.hash.outputLen,k.nByteLength,k.hmac)(O,N)}o.BASE._setWindowSize(8);function j(g,E,p,O=T){var ht;const N=g;E=U("msgHash",E),p=U("publicKey",p);const{lowS:k,prehash:M,format:V}=O;if(Qt(O),"strict"in O)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");const $=typeof N=="string"||Zt(N),Y=!$&&!V&&typeof N=="object"&&N!==null&&typeof N.r=="bigint"&&typeof N.s=="bigint";if(!$&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let P,st;try{if(Y&&(P=new a(N.r,N.s)),$){try{V!=="compact"&&(P=a.fromDER(N))}catch(ct){if(!(ct instanceof W.Err))throw ct}!P&&V!=="der"&&(P=a.fromCompact(N))}st=o.fromHex(p)}catch{return!1}if(!P||k&&P.hasHighS())return!1;M&&(E=n.hash(E));const{r:Q,s:_t}=P,et=q(E),it=f(_t),Nt=c(et*it),lt=c(Q*it),nt=(ht=o.BASE.multiplyAndAddUnsafe(st,Nt,lt))==null?void 0:ht.toAffine();return nt?c(nt.x)===Q:!1}return{CURVE:n,getPublicKey:h,getSharedSecret:v,sign:L,verify:j,ProjectivePoint:o,Signature:a,utils:l}}function We(e,n){const t=e.ORDER;let r=G;for(let S=t-R;S%J===G;S/=J)r+=R;const s=r,i=J<<s-R-R,c=i*J,f=(t-R)/c,o=(f-R)/J,d=c-R,w=i,x=e.pow(n,f),u=e.pow(n,(f+R)/J);let b=(S,m)=>{let a=x,l=e.pow(m,d),h=e.sqr(l);h=e.mul(h,m);let y=e.mul(S,h);y=e.pow(y,o),y=e.mul(y,l),l=e.mul(y,m),h=e.mul(y,S);let v=e.mul(h,l);y=e.pow(v,w);let _=e.eql(y,e.ONE);l=e.mul(h,u),y=e.mul(v,a),h=e.cmov(l,h,_),v=e.cmov(y,v,_);for(let q=s;q>R;q--){let B=q-J;B=J<<B-R;let I=e.pow(v,B);const A=e.eql(I,e.ONE);l=e.mul(h,a),a=e.mul(a,a),I=e.mul(v,a),h=e.cmov(l,h,A),v=e.cmov(I,v,A)}return{isValid:_,value:h}};if(e.ORDER%Jt===St){const S=(e.ORDER-St)/Jt,m=e.sqrt(e.neg(n));b=(a,l)=>{let h=e.sqr(l);const y=e.mul(a,l);h=e.mul(h,y);let v=e.pow(h,S);v=e.mul(v,y);const _=e.mul(v,m),q=e.mul(e.sqr(v),l),B=e.eql(q,a);let I=e.cmov(_,v,B);return{isValid:B,value:I}}}return b}function Xe(e,n){if(ae(e),!e.isValid(n.A)||!e.isValid(n.B)||!e.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const t=We(e,n.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,i,c,f,o,d,w,x;s=e.sqr(r),s=e.mul(s,n.Z),i=e.sqr(s),i=e.add(i,s),c=e.add(i,e.ONE),c=e.mul(c,n.B),f=e.cmov(n.Z,e.neg(i),!e.eql(i,e.ZERO)),f=e.mul(f,n.A),i=e.sqr(c),d=e.sqr(f),o=e.mul(d,n.A),i=e.add(i,o),i=e.mul(i,c),d=e.mul(d,f),o=e.mul(d,n.B),i=e.add(i,o),w=e.mul(s,c);const{isValid:u,value:b}=t(i,d);x=e.mul(s,r),x=e.mul(x,b),w=e.cmov(w,c,u),x=e.cmov(x,b,u);const S=e.isOdd(r)===e.isOdd(x);return x=e.cmov(e.neg(x),x,S),w=e.div(w,f),{x:w,y:x}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Qe(e){return{hash:e,hmac:(n,...t)=>ce(e,n,_e(...t)),randomBytes:se}}function Je(e,n){const t=r=>$e({...e,...Qe(r)});return{...t(n),create:t}}const Fe=X;function F(e,n){if(gt(e),gt(n),e<0||e>=1<<8*n)throw new Error("invalid I2OSP input: "+e);const t=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)t[r]=e&255,e>>>=8;return new Uint8Array(t)}function tn(e,n){const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e[r]^n[r];return t}function gt(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function en(e,n,t,r){dt(e),dt(n),gt(t),n.length>255&&(n=r(D(Pt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:i}=r,c=Math.ceil(t/s);if(t>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=D(n,F(n.length,1)),o=F(0,i),d=F(t,2),w=new Array(c),x=r(D(o,e,d,F(0,1),f));w[0]=r(D(x,F(1,1),f));for(let b=1;b<=c;b++){const S=[tn(x,w[b-1]),F(b+1,1),f];w[b]=r(D(...S))}return D(...w).slice(0,t)}function nn(e,n,t,r,s){if(dt(e),dt(n),gt(t),n.length>255){const i=Math.ceil(2*r/8);n=s.create({dkLen:i}).update(Pt("H2C-OVERSIZE-DST-")).update(n).digest()}if(t>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:t}).update(e).update(F(t,2)).update(n).update(F(n.length,1)).digest()}function Ft(e,n,t){bt(t,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:i,hash:c,expand:f,DST:o}=t;dt(e),gt(n);const d=typeof o=="string"?Pt(o):o,w=r.toString(2).length,x=Math.ceil((w+s)/8),u=n*i*x;let b;if(f==="xmd")b=en(e,d,u,c);else if(f==="xof")b=nn(e,d,u,s,c);else if(f==="_internal_pass")b=e;else throw new Error('expand must be "xmd" or "xof"');const S=new Array(n);for(let m=0;m<n;m++){const a=new Array(i);for(let l=0;l<i;l++){const h=x*(l+m*i),y=b.subarray(h,h+x);a[l]=Z(Fe(y),r)}S[m]=a}return S}function rn(e,n){const t=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[i,c,f,o]=t.map(d=>d.reduce((w,x)=>e.add(e.mul(w,r),x)));return r=e.div(i,c),s=e.mul(s,e.div(f,o)),{x:r,y:s}}}function on(e,n,t){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,s){const i=Ft(r,2,{...t,DST:t.DST,...s}),c=e.fromAffine(n(i[0])),f=e.fromAffine(n(i[1])),o=c.add(f).clearCofactor();return o.assertValidity(),o},encodeToCurve(r,s){const i=Ft(r,1,{...t,DST:t.encodeDST,...s}),c=e.fromAffine(n(i[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const i of r)if(typeof i!="bigint")throw new Error("mapToCurve: expected array of bigints");const s=e.fromAffine(n(r)).clearCofactor();return s.assertValidity(),s}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Et=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),At=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),mt=BigInt(1),It=BigInt(2),te=(e,n)=>(e+n/It)/n;function me(e){const n=Et,t=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),o=BigInt(88),d=e*e*e%n,w=d*d*e%n,x=K(w,t,n)*w%n,u=K(x,t,n)*w%n,b=K(u,It,n)*d%n,S=K(b,s,n)*b%n,m=K(S,i,n)*S%n,a=K(m,f,n)*m%n,l=K(a,o,n)*a%n,h=K(l,f,n)*m%n,y=K(h,t,n)*w%n,v=K(y,c,n)*S%n,_=K(v,r,n)*d%n,q=K(_,It,n);if(!tt.eql(tt.sqr(q),e))throw new Error("Cannot find square root");return q}const tt=de(Et,void 0,void 0,{sqrt:me}),Ot=Je({a:BigInt(0),b:BigInt(7),Fp:tt,n:At,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=At,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-mt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,c=BigInt("0x100000000000000000000000000000000"),f=te(i*e,n),o=te(-r*e,n);let d=Z(e-f*t-o*s,n),w=Z(-f*r-o*i,n);const x=d>c,u=w>c;if(x&&(d=n-d),u&&(w=n-w),d>c||w>c)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:x,k1:d,k2neg:u,k2:w}}}},xt),ye=BigInt(0),ee={};function qt(e,...n){let t=ee[e];if(t===void 0){const r=xt(Uint8Array.from(e,s=>s.charCodeAt(0)));t=D(r,r),ee[e]=t}return xt(D(t,...n))}const jt=e=>e.toRawBytes(!0).slice(1),Ut=e=>ft(e,32),kt=e=>Z(e,Et),yt=e=>Z(e,At),Kt=Ot.ProjectivePoint,sn=(e,n,t)=>Kt.BASE.multiplyAndAddUnsafe(e,n,t);function Mt(e){let n=Ot.utils.normPrivateKeyToScalar(e),t=Kt.fromPrivateKey(n);return{scalar:t.hasEvenY()?n:yt(-n),bytes:jt(t)}}function be(e){ot("x",e,mt,Et);const n=kt(e*e),t=kt(n*e+BigInt(7));let r=me(t);r%It!==ye&&(r=kt(-r));const s=new Kt(e,r,mt);return s.assertValidity(),s}const at=X;function Ee(...e){return yt(at(qt("BIP0340/challenge",...e)))}function cn(e){return Mt(e).bytes}function an(e,n,t=se(32)){const r=U("message",e),{bytes:s,scalar:i}=Mt(n),c=U("auxRand",t,32),f=Ut(i^at(qt("BIP0340/aux",c))),o=qt("BIP0340/nonce",f,s,r),d=yt(at(o));if(d===ye)throw new Error("sign failed: k is zero");const{bytes:w,scalar:x}=Mt(d),u=Ee(w,s,r),b=new Uint8Array(64);if(b.set(w,0),b.set(Ut(yt(x+u*i)),32),!pe(b,r,s))throw new Error("sign: Invalid signature produced");return b}function pe(e,n,t){const r=U("signature",e,64),s=U("message",n),i=U("publicKey",t,32);try{const c=be(at(i)),f=at(r.subarray(0,32));if(!Bt(f,mt,Et))return!1;const o=at(r.subarray(32,64));if(!Bt(o,mt,At))return!1;const d=Ee(Ut(f),jt(c),s),w=sn(c,o,yt(-d));return!(!w||!w.hasEvenY()||w.toAffine().x!==f)}catch{return!1}}const un=(()=>({getPublicKey:cn,sign:an,verify:pe,utils:{randomPrivateKey:Ot.utils.randomPrivateKey,lift_x:be,pointToBytes:jt,numberToBytesBE:ft,bytesToNumberBE:X,taggedHash:qt,mod:Z}}))(),fn=(()=>rn(tt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(n=>BigInt(n)))))(),dn=(()=>Xe(tt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:tt.create(BigInt("-11"))}))(),ve=(()=>on(Ot.ProjectivePoint,e=>{const{x:n,y:t}=dn(tt.create(e[0]));return fn(n,t)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:tt.ORDER,m:1,k:128,expand:"xmd",hash:xt}))(),hn=(()=>ve.hashToCurve)(),wn=(()=>ve.encodeToCurve)();export{wn as encodeToCurve,hn as hashToCurve,un as schnorr,Ot as secp256k1};
